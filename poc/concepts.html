<!DOCTYPE html><html><head><title>Concepts</title>
<script src="https://unpkg.com/vue/dist/vue.js"></script>
<link rel="stylesheet" type="text/css" href="basic.css">
<link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.1/css/font-awesome.min.css">
<style type="text/css">
    body {
        padding-top: 5em;
    }
</style>
</head><body>

<div id="EditorToolbar"></div>

<div id="Stage2" class="VerticalSpacing">
    <comp-content v-for="comp in components" :comp_info="comp"></comp-content>
</div>

<div id="Thumbnails">
    <thumbnail v-for="comp in components" :props="comp"></thumbnail>
</div>

<div class="overlay"></div>
<div class="decision">
    <div>Are you sure you want to delete this content?</div>
    <button class="yes">Yes, delete</button>
    <button class="no">Nope, stop</button>
</div>

<br><br>
<!-- Each component staged needs to have data stored on the element
     for when items are rearranged within the DOM. I cannot figure out
     a resonable way to update component data placement after dragula
     has fired its 'drop' hook. On 'save', the data from each DOM node
     is saved in a new array.
-->
<!-- <div id="test" :data-comp-info="this.$data | toJson">
    <div v-editor:content-title></div>
    <div v-editor:content></div>
</div> -->

<script src="//cdn.tinymce.com/4/tinymce.min.js"></script>
<script type="text/javascript" src="https://code.jquery.com/jquery-3.1.1.min.js"></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/dragula/3.7.2/dragula.min.js'></script>
<script type="text/javascript">

Array.prototype.insert = function(index, item) {
    this.splice(index, 0, item);
}
Array.prototype.remove = function(index) {
    this.splice(index, 1);
}
Array.prototype.reorder = function(from, to) {
    this.splice(to, 0, this.splice(from, 1)[0]);
}

var ID = 0;
/*
    I need something that will insert saved html data into a container
    where the container is a tinymce editor instance. However, when the
    user updates the DOM via editing, I want the data to update but I 
    don't want the DOM to rerender since it has already changed and if it
    rerenders it will refocus the carrot. So, basically:
    Data -> DOM (one-way on init)
    DOM -> data (one-way on editing)
*/
Vue.directive('editor', {
    bind: function(el, binding, vnode) {
        var id = genID(10);
        // On intial binding, load what's in the data
        // then make unique editor id and init tinymce
        console.log(vnode.context);
        $(el).html(vnode.context[binding.arg]);
        $(el).attr('data-editor-id', id);
        tinymce.init({
            selector: '[data-editor-id='+id+']',
            plugins: 'link lists paste textpattern autolink',
            toolbar: 'undo redo bold italic alignleft aligncenter link bullist numlist',
            insert_toolbar: false,
            fixed_toolbar_container: '#EditorToolbar',
            menubar: false,
            inline: true,
            // attach a handler that will update the specific data
            // on keyup and any action that can be undone
            setup: function(ed) {
                ed.on('Change keyup', function() {
                    vnode.context[binding.arg] = ed.getContent();
                })
            }
        })
    }
})

// var test = new Vue({
//     el: '#test',
//     data: {
//         'content-title': '<h1>Default Content Title</h1>',
//         'content': '<p>Default content copy paragraph.</p>'
//     },
//     filters: {
//         toJson: function(obj) {
//             return JSON.stringify(obj);
//         }
//     },
//     mounted: function() {
//         $(this.$el).attr('data-comp-info', JSON.stringify(this.$data));
//     }
// })

// Toolbar is given to every staged component
Vue.component('comp-toolbar', {
    props: ['props'],
    template: '\
        <div class="comp-toolbar">\
            <button class="btn-toolbar grab"><i class="fa fa-arrows"></i></button>\
            <button class="btn-toolbar"><i class="fa fa-clone"></i></button>\
            <button class="btn-toolbar" @click="remove"><i class="fa fa-trash-o"></i></button>\
            <button class="btn-toolbar"><i class="fa fa-cog"></i></button>\
        </div>',
    methods: {
        remove: function() {
            this.$emit('remove');
        }
    }
})

// Meta component - for stage
Vue.component('comp-content', {
    props: ['comp_info'],
    template: '\
        <div class="comp-content">\
            <component :is="comp_info.name" :comp_config="comp_info.config"></component>\
            <comp-toolbar v-on:remove="remove"></comp-toolbar>\
        </div>',
    methods: {
        remove: function() {
            var compId = this.props.id;
            var parent = this.$parent;
            this.$parent.components.forEach(function(comp, i) {
                if (comp.id === compId) {
                    decision('Are you sure you want to delete this content?',
                             'Yes, delete',
                             'No, stop',
                             function() {
                                parent.components.remove(i);
                             })
                }
            })
        }
    },
    // mounted: function() {
    //     this.props.id = ID++;
    //     $(this.$el).attr('data-comp', JSON.stringify(this.props));
    // }
})

// Meta component - for thumbnails
Vue.component('thumbnail', {
    props: ['props'],
    template: '\
        <div class="comp-thumbnail">\
            <span>{{ props.display }}</span>\
            <component :is="props.name" :props="props.config"></component>\
        </div>',
    mounted: function() {
        $(this.$el).attr('data-comp', JSON.stringify(this.props));
    }
})

// Content component
Vue.component('content-title', {
    props: ['props'],
    template: '<div class="editor-simple" v-html="props.content"></div>'
})

Vue.component('editor', {
    props: ['propname'],
    template: '<div></div>',
    mounted: function() {
        var _this = this;
        var id = genID(10);
        $(_this.$el).attr('id', id);
        if ($(_this.$root.$el).attr('id') !== 'Thumbnails') {
            tinymce.init({
                selector: '#' + id,
                plugins: 'link lists paste textpattern autolink',
                toolbar: 'undo redo bold italic alignleft aligncenter link bullist numlist',
                insert_toolbar: false,
                fixed_toolbar_container: '#EditorToolbar',
                menubar: false,
                inline: true,
                setup: function(ed) {
                    setTimeout(function() {
                        ed.on('NodeChange', function() {
                            var compElem = $(_this.$parent.$parent.$el);
                            var data = JSON.parse(compElem.attr('data-comp'));
                            data[_this.propname] = ed.getContent();
                            compElem.attr('data-comp', JSON.stringify(data));
                        }); 
                    }, 100);
                }
            })
        }
    }
})

Vue.component('copy', {
    props: ['comp_config'],
    template: '<div v-editor:copy></div>'
})


var stage = new Vue({
    el: '#Stage2',
    data: {
        components: []
    }
})

var thumbnails = new Vue({
    el: '#Thumbnails',
    data: {
        components: [
            {
                name: 'copy',
                display: 'Copy',
                type: 'content',
                id: null,
                config: {
                    copy: '<p>Lorem ipsum copi textum</p>'
                }
            }
        ]
    }
})

var Stage = $('#Stage2')[0],
    Thumbnails = $('#Thumbnails')[0],
    StartIndex = 0,
    EndIndex = 0;

dragula([Stage, Thumbnails], {
    moves: function(el, container, grabber) {
        return container === Thumbnails || ($(grabber).hasClass('grab') || $(grabber).hasClass('fa-arrows'));
    },
    copy: function(el, source) {
        return source === Thumbnails;
    },
    accepts: function(el, target) {
        return target !== Thumbnails;
    }
}).on('drop', function(el, target, source, sibling) {
    if (source === Thumbnails && target === Stage) {
        EndIndex = getIndex(Stage, el);
        $(el).remove();
        var data = JSON.parse(JSON.stringify(thumbnails.components[StartIndex]))
        stage.components.insert(EndIndex, data);
    }
}).on('drag', function(el, source) {
    if (source === Thumbnails) {
        StartIndex = getIndex(Thumbnails, el);
    }
})


$('.no, .yes').click(function() {
    $('.overlay, .decision').css({display: 'none'});
})


function decision(decMsg, yesMsg, noMsg, cb) {
    $('.overlay, .decision').css({display: 'block'});
    $('.decision div').html(decMsg);
    $('.yes').html('<i class="fa fa-check"></i> ' + yesMsg);
    $('.no').html('<i class="fa fa-close"></i> ' + noMsg);
    $('.yes').click(cb);
}

function random(min, max) {
    return Math.floor(Math.random() * (max - min + 1) + min);
}
  
function genID(num) {
    var id = 'ID-', i = 1;
    while (i <= num) {
        if (i % 2 === 0) {
            id += String.fromCharCode(random(65, 90));
        } else {
            id += String.fromCharCode(random(48, 57));
        }
        i++;
    }
    return id;
}

function getIndex(area, item) {
    var index;
    $(area).children().each(function(i) {
        if (this === item) {
            index = i;
            return false;
        }
    })
    return index;
}

</script></body></html>