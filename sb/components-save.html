<!DOCTYPE html><html><head><title>components-add-remove</title>
<script src="https://unpkg.com/vue/dist/vue.js"></script>
<script src="//cdn.tinymce.com/4/tinymce.min.js"></script>
<script type="text/javascript" src="https://code.jquery.com/jquery-3.1.1.min.js"></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/dragula/3.7.2/dragula.min.js'></script>
<link rel="stylesheet" type="text/css" href="basic.css">
</head><body>

<div id="EditorToolbar"></div>
<div id="app" class="VerticalSpacing">
    <div class="Toolbar-Main">
        <button class="btn" @click="load()">Load</button>
        <button class="btn" @click="save()">Save</button>
        <button class="btn" @click="request()">Request</button>
        <div id="Thumbnails">
            <div class="CompThumbWrap" v-for="(comp, i) in defaultComps" :data-component="comp.type">
                <p style="color: rgba(0,0,0,0.3); font-size:0.8em; margin-bottom: 5px">{{ comp.type }}</p>
                <component 
                    class="CompThumbnail"
                    :is="comp.type"
                    :properties="comp.properties"
                ></component>
            </div>
        </div>
    </div>
    <div class="VerticalSpacing" id="Stage">
        <component 
            class="VerticalSpacing"
            v-for="comp in comps"
            :is="comp.type"
            :properties="comp.properties"
        ></component>
    </div>
    <div>
        <aside class="dataView"><pre>{{ savedComps | prettyJson }}</pre></aside>
    </div>
</div>

<script type="text/javascript">

/*
    Component names start with lowercase 'c' to avoide Vue's privledged name error.
    Every component needs to take a prop called 'properties'.

    Here is how you handle components with tinyMCE editor instance(s):

        - give a class name indicating the editor type ('editor-simple', 'editor-robust')
        - give a data-prop attribute to link with the property in question
        - use the v-html directive to ensure the editor contents update in HTML
        - we use tinyMCE's inline mode so editor instances can only be placed on block elements
        - if editable regions exist, give the component `mounted: initEditing`. This will
          initiate editing instances once the component is fully mounted
        - Every component available should be listed in app.defaultComps so they can be
          added to the toolbar for display. Make sure you added properties.defaultComp = true
          in defaultComps so that the editor will not initialize
        - In order to make the editor instance conditional, add properties.Classes and declare
          when a
*/
var cTitle = {
    props: ['properties'],
    template: '<h1 class="editor-simple" data-prop="text" v-html="properties.text">{{ properties.text }}</h1>',
    mounted: function() {
        if (this.$parent.isMounted) {
            console.log('initiate editing');
            initEditing(this);
        }
    },
}

var cCopy = {
    props: ['properties'],
    template: '\
        <div class="editor-robust VerticalSpacing" data-prop="content" v-html="properties.content">\
            {{ properties.content }}\
        </div>',
    mounted: function() {
        if (this.$parent.isMounted) {
            console.log('initiate editing');
            initEditing(this);
        }
    }
}

var cHeadingBlock = {
    props: ['properties'],
    template: '\
        <div class="wrapper VerticalSpacing">\
            <div :class="properties.Classes.title" data-prop="titleText" v-html="properties.titleText"></div>\
            <hr>\
            <div :class="properties.Classes.copy" data-prop="copyText" v-html="properties.copyText"></div>\
        </div>',
    mounted: function() {
        if (this.$parent.isMounted) {
            console.log('initiate editing');
            initEditing(this);
        }
    }
}

/*
    Just some example dummy content that we would get back from a database for
    any given piece of content to be edited
*/
var DUMMY_SAVED = [
  {
    "type": "Heading Block",
    "properties": {
      "Classes": {
        "title": {
            'editor-simple': true
        },
        "copy": {
            "editor-robust": true,
            "VerticalSpacing": true
        }
      },
      "titleText": "<h1 style=\"text-align: center;\">PULLED FROM A DATABASE!</h1>",
      "copyText": "<p>You need to dynamically engineer your market foci to increase your bandwidth velocity. You need to ethically align your organic growths to increase your cloud velocity. Going forward, our knowledge transfer emerging market will deliver value to standpoints. In the vertical space, industry is globally impacting its best-of-breed brands.</p>\n<p>We use our corporate stakeholders to effectively manage our stack expectations. In the future, will you be able to iteratively reuse game changers in your business? You need to virtually facilitate your platforms to increase your core asset velocity. Proactively deep-diving strategically customer-focused big datas is crucial to our long-term standard setter.</p>\n<p>Reliably touching base about calibrating stand-ups will make us leaders in the competitive milestone industry. Change the way you do business - adopt best-in-class synergies. Mission critical capabilities are becoming end-to-end proposition experts. Change the way you do business - adopt holistic ballpark figures.</p>\n<p>It's critical that we give 110% when intelligently growing prince2 practitioners. We aim to conservatively strategize our diversity by virtually monetizing our innovative actionable enterprises. Our business offshores best practices to reliably and ethically connect our next-generation industry leader. Going forward, our unparalleled visibility will deliver value to drivers.</p>"
    }
  }
]

var app = new Vue({
    el: '#app',
    data: {
        isMounted: false,
        comps: [],
        savedComps: [],
        defaultComps: {
            'Content Title': {
                type: 'Content Title',
                properties: {
                    text: 'Lorem Ipsum'
                }
            },
            'Copy': {
                type: 'Copy',
                properties: {
                    content: 'Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque nisl velit, egestas eu fermentum fermentum, feugiat tincidunt purus. Morbi massa massa, efficitur imperdiet turpis at, tempus eleifend mi. Donec ac mi feugiat, mattis ipsum non, ornare dolor.'
                }
            },
            'Heading Block': {
                type: 'Heading Block',
                properties: {
                    Classes: {
                        title: {
                            'editor-simple': false
                        },
                        copy: {
                            'editor-robust': false,
                            'VerticalSpacing': true
                        }
                    },
                    titleText: '<h1>Lorem Ipsum</h1>',
                    copyText: '<p>This is some default copy text for your viewing pleasure.</p>'
                }
            }
        }
    },
    /*
        This should be abstracted away into an interface for creating components.
        The human readable name should be the key (which will generate the list of
        available components for any given template) and the value should be a direct
        reference to the component data object.
    */
    components: {
        'Content Title': cTitle,
        'Copy': cCopy,
        'Heading Block': cHeadingBlock,
    },
    /*
        This is just so we can print data at the bottom of the screen as a check
    */
    filters: {
        prettyJson: function(obj) {
            return JSON.stringify(obj, null, 2);
        }
    },
    methods: {
        /*
            Pretty straightforward: empty the current comps, then on the next tick
            (since Vue asychronously updates DOM), replace with saved data.
        */
        load: function() {
            var _app = this;
            _app.comps = [];
            Vue.nextTick(function() {
                _app.comps = _app.savedComps;
            })
        },
        /*
            Save is less straightforward: We need to save the unique properties of each
            component that uses editable regions by using tinyMCE's Editor API to grab HTML.
            Otherwise, we're going to be saving some unwanted tinyMCE data attributes in our
            content.

                1. We cycle through each component first logging the index as we go
                2. Then we go through each editing instance found in that component
                3. We grab the property (hence adding data-prop)
                4. We grab the editor using tinymce editor id
                5. Then we reference the app's child by the index and set the relevant
                   property to the return value of editor.getContent()
                6. Finally, we set savedComps to a copy of the full set of data
        */
        save: function() {
            var _app = this;
            _app.$children.forEach(function(comp, i) {
                var _index = i;
                $(comp.$el).find('[class*=editor-]').each(function() {
                    var _prop = $(this).attr('data-prop');
                    var editor = tinymce.get($(this).attr('id'));
                    _app.$children[_index].properties[_prop] = editor.getContent();
                });
            })
            this.savedComps = JSON.parse(JSON.stringify(this.comps));
        },
        /*
            Just to mimic requesting data from a databse
        */
        request: function() {
            if (DUMMY_SAVED) {
                this.savedComps = DUMMY_SAVED;
            }
        }
    },
    mounted: function() {
        this.isMounted = true;
        adjustThumbnailHeight(this.$children);
    }
})


/*
    Helper functions
*/
function adjustThumbnailHeight(thumbs) {
    setTimeout(function() {
        thumbs.forEach(function(thumb) {
            $(thumb.$el).parent().each(function() {
                var height = $(this).height();
                $(this).css({ height: (height + 115) / 2 + 'px' })
            });
        });
    }, 50)
    
}

function copy(obj) {
    return JSON.parse(JSON.stringify(obj));
}

function editorGlobal() {
    return {
        plugins: 'image table link lists paste textpattern autolink',
        toolbar: 'undo redo bold italic alignleft aligncenter link',
        insert_toolbar: false,
        fixed_toolbar_container: '#EditorToolbar',
        menubar: false,
        inline: true
    }
}

function editorSimple(id) {
    var config = editorGlobal();
    config.selector = '#'+id +'.editor-simple, #'+id+' .editor-simple';
    return config;
}

function editorRobust(id) {
    var config = editorGlobal();
    config.selector = '#'+id +'.editor-robust, #'+id+' .editor-robust';
    config.toolbar += ' bullist numlist';
    return config;
}

function initEditing(comp) {
    var $comp = $(comp.$el),
        id = genID(12);
    $comp.attr('id', id);
    tinymce.init(editorSimple(id));
    tinymce.init(editorRobust(id));
}


function random(min, max) {
    return Math.floor(Math.random() * (max - min + 1) + min);
}
  
function genID(num) {
    var id = 'ID-', i = 1;
    while (i <= num) {
        if (i % 2 === 0) {
            id += String.fromCharCode(random(65, 90));
        } else {
            id += String.fromCharCode(random(48, 57));
        }
        i++;
    }
    return id;
}

Array.prototype.insert = function(index, item) {
    this.splice(index, 0, item);
}


/*
    Dragula implementation
*/

var Thumbnails = $('#Thumbnails')[0],
    Stage = $('#Stage')[0];

dragula([ Thumbnails, Stage ], {
    copy: function(el, source) {
        return source === Thumbnails;
    },
    accepts: function(el, target) {
        return target === Stage;
    },
    removeOnSpill: function(el, target) {
        return target === Stage;
    }
}).on('drop', function(el, target, source, sibling) {
    if (source === Stage && target === Stage) {
        console.log('Sorted staged components');
    }
    if (source === Thumbnails) {
        var compName = $(el).attr('data-component');
        var stageSpot = 0;
        $(target).children().each(function(i) {
            if ($(this).hasClass('CompThumbWrap')) {
                console.log($(this));
                stageSpot = i;
            }
        })
        $(el).remove();
        console.log('Place in line: ' + stageSpot);
        var compData = JSON.stringify(app.defaultComps[compName]);
        app.comps.insert(stageSpot, JSON.parse(compData));
    }
}).on('remove', function(el, container, source) {
    if (source === Stage) {
        console.log('Remove component from stage')
    }
})


</script></body></html>