<!DOCTYPE html><html><head><title>components-add-remove</title>
<script src="https://unpkg.com/vue/dist/vue.js"></script>
<script src="//cdn.tinymce.com/4/tinymce.min.js"></script>
<script type="text/javascript" src="https://code.jquery.com/jquery-3.1.1.min.js"></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/dragula/3.7.2/dragula.min.js'></script>
<link rel="stylesheet" type="text/css" href="basic.css">
</head><body>

<div id="EditorToolbar"></div>
<div id="app" class="VerticalSpacing">
    <div class="Toolbar-Main">
        <button class="btn" @click="load()">Load</button>
        <button class="btn" @click="save()">Save</button>
        <button class="btn" @click="request()">Request</button>
        <div id="Thumbnails">
            <div class="CompThumbWrap" v-for="(comp, i) in defaultComps" :data-component="comp.type">
                <p style="color: rgba(0,0,0,0.3); font-size:0.8em; margin-bottom: 5px">{{ comp.type }}</p>
                <component 
                    class="CompThumbnail"
                    :is="comp.type"
                    :properties="comp.properties"
                ></component>
            </div>
        </div>
    </div>
    <div id="Stage" class="VerticalSpacing">
        <component 
            class="StageComponent VerticalSpacing"
            v-for="comp in stageComps"
            :is="comp.type"
            :properties="comp.properties"
            :data-obj="toJson(comp)"
        ></component>
    </div>
    <div>
        <aside class="dataView"><pre>{{ savedComps | prettyJson }}</pre></aside>
    </div>
    <!-- <div id="Trash">Trash</div> -->
</div>

<script type="text/javascript">

/*
    app
        thumbnails
            app.thumbnails
        stage
            app.stagedComponents
            app.savedData
    
    Component names start with lowercase 'c' to avoide Vue's privledged name error.
    Every component needs to take a prop called 'properties'.

    Here is how you handle components with tinyMCE editor instance(s):

        - give a class name indicating the editor type ('editor-simple', 'editor-robust')
        - give a data-prop attribute to link with the property in question
        - use the v-html directive to ensure the editor contents update in HTML
        - we use tinyMCE's inline mode so editor instances can only be placed on block elements
        - if editable regions exist, give the component `mounted: initEditing`. This will
          initiate editing instances once the component is fully mounted
        - Every component available should be listed in app.defaultComps so they can be
          added to the toolbar for display. Make sure you added properties.defaultComp = true
          in defaultComps so that the editor will not initialize
        - In order to make the editor instance conditional, add properties.Classes and declare
          when a
*/
var cTitle = {
    props: ['properties'],
    template: '<h1 class="editor-simple" data-prop="text" v-html="properties.text">{{ properties.text }}</h1>',
    mounted: function() {
        if (this.$parent.isMounted) {
            initEditing(this);
        }
    },
}

var cCopy = {
    props: ['properties'],
    template: '\
        <div class="editor-robust VerticalSpacing" data-prop="content" v-html="properties.content">\
            {{ properties.content }}\
        </div>',
    mounted: function() {
        if (this.$parent.isMounted) {
            initEditing(this);
        }
    }
}

var cHeadingBlock = {
    props: ['properties'],
    template: '\
        <div class="wrapper">\
            <div class="editor-simple" data-prop="titleText" v-html="properties.titleText"></div>\
            <hr>\
            <div class="editor-robust VerticalSpacing" data-prop="copyText" v-html="properties.copyText"></div>\
        </div>',
    mounted: function() {
        if (this.$parent.isMounted) {
            initEditing(this);
        }
    }
}

/*
    Just some example dummy content that we would get back from a database for
    any given piece of content to be edited
*/
var DUMMY_SAVED = [
  {
    "type": "Heading Block",
    "properties": {
      "titleText": "<h1 style=\"text-align: center;\">PULLED FROM A DATABASE!</h1>",
      "copyText": "<p>You need to dynamically engineer your market foci to increase your bandwidth velocity. You need to ethically align your organic growths to increase your cloud velocity. Going forward, our knowledge transfer emerging market will deliver value to standpoints. In the vertical space, industry is globally impacting its best-of-breed brands.</p>\n<p>We use our corporate stakeholders to effectively manage our stack expectations. In the future, will you be able to iteratively reuse game changers in your business? You need to virtually facilitate your platforms to increase your core asset velocity. Proactively deep-diving strategically customer-focused big datas is crucial to our long-term standard setter.</p>\n<p>Reliably touching base about calibrating stand-ups will make us leaders in the competitive milestone industry. Change the way you do business - adopt best-in-class synergies. Mission critical capabilities are becoming end-to-end proposition experts. Change the way you do business - adopt holistic ballpark figures.</p>\n<p>It's critical that we give 110% when intelligently growing prince2 practitioners. We aim to conservatively strategize our diversity by virtually monetizing our innovative actionable enterprises. Our business offshores best practices to reliably and ethically connect our next-generation industry leader. Going forward, our unparalleled visibility will deliver value to drivers.</p>"
    }
  }
]

var app = new Vue({
    el: '#app',
    data: {
        isMounted: false,
        comps: [],
        stageComps: [],
        savedComps: [],
        defaultComps: {
            'Content Title': {
                type: 'Content Title',
                properties: {
                    text: 'Heading'
                }
            },
            'Copy': {
                type: 'Copy',
                properties: {
                    content: 'Lorem ipsum dolor sit amet, consectetur adipiscing elit.'
                }
            },
            'Heading Block': {
                type: 'Heading Block',
                properties: {
                    titleText: '<h1>Lorem Ipsum</h1>',
                    copyText: '<p>This is some default copy text for your viewing pleasure.</p>'
                }
            }
        }
    },
    /*
        This should be abstracted away into an interface for creating components.
        The human readable name should be the key (which will generate the list of
        available components for any given template) and the value should be a direct
        reference to the component data object.
    */
    components: {
        'Content Title': cTitle,
        'Copy': cCopy,
        'Heading Block': cHeadingBlock,
    },
    /*
        This is just so we can print data at the bottom of the screen as a check
    */
    filters: {
        prettyJson: function(obj) {
            return JSON.stringify(obj, null, 2);
        }
    },
    methods: {
        /*
            Pretty straightforward: empty the current stageComps, then on the next tick
            (since Vue asychronously updates DOM), replace with saved data.
        */
        load: function() {
            var _app = this;
            _app.stageComps = [];
            Vue.nextTick(function() {
                _app.stageComps = _app.savedComps;
            })
        },
        /*
            Save is less straightforward: We need to save the unique properties of each
            component that uses editable regions by using tinyMCE's Editor API to grab HTML.
            Otherwise, we're going to be saving some unwanted tinyMCE data attributes in our
            content.
        */
        save: function() {
            var saved = this.savedComps = [];

            $('#Stage').children().each(function(comp) {
                saved.push(JSON.parse($(this).attr('data-obj')));
            })
        },
        /*
            Just to mimic requesting data from a databse
        */
        request: function() {
            if (DUMMY_SAVED) {
                this.savedComps = DUMMY_SAVED;
            }
        },
        toJson: function(obj) {
            return JSON.stringify(obj);
        }
    },
    mounted: function() {
        this.isMounted = true;
        adjustThumbnailHeight(this.$children);
    }
})


/*
    Helper functions
*/
function saveComponent(child, editor) {
    var _prop = $(this).attr('data-prop');
    if (_prop) {
        var editor = tinymce.get($(this).attr('id'));
        child.properties[_prop] = editor.getContent();
    }
}

function adjustThumbnailHeight(thumbs) {
    setTimeout(function() {
        thumbs.forEach(function(thumb) {
            $(thumb.$el).parent().each(function() {
                var height = $(this).height();
                $(this).css({ height: (height + 115) / 2 + 'px' })
            });
        });
    }, 50)
    
}

function copy(obj) {
    return JSON.parse(JSON.stringify(obj));
}

function editorGlobal() {
    return {
        plugins: 'image table link lists paste textpattern autolink',
        toolbar: 'undo redo bold italic alignleft aligncenter link',
        insert_toolbar: false,
        fixed_toolbar_container: '#EditorToolbar',
        menubar: false,
        inline: true
    }
}

function initEditing(comp) {
    var $comp = $(comp.$el),
        id = genID(12);
    $comp.attr('id', id);
    var config = editorGlobal();
    config.setup = function(editor) {
        editor.on('NodeChange', function(e) {
            var edElem = $(editor.getBody());
            var data = JSON.parse($comp.attr('data-obj'));
            var prop = edElem.attr('data-prop');
            data.properties[prop] = editor.getContent();
            $comp.attr('data-obj', JSON.stringify(data));
            app.save();
        })
    };
    config.selector = '#'+id +'.editor-simple, #'+id+' .editor-simple';
    tinymce.init(config);
    config.selector = '#'+id +'.editor-robust, #'+id+' .editor-robust';
    config.toolbar += ' bullist numlist';
    tinymce.init(config);
}


function random(min, max) {
    return Math.floor(Math.random() * (max - min + 1) + min);
}
  
function genID(num) {
    var id = 'ID-', i = 1;
    while (i <= num) {
        if (i % 2 === 0) {
            id += String.fromCharCode(random(65, 90));
        } else {
            id += String.fromCharCode(random(48, 57));
        }
        i++;
    }
    return id;
}

Array.prototype.insert = function(index, item) {
    this.splice(index, 0, item);
}
Array.prototype.remove = function(index) {
    this.splice(index, 1);
}
Array.prototype.reindex = function() {
    var arr = this;
    return arr.map(function(item, index) {
        arr[index] = index;
        return item; 
    })
}

/*
    Dragula implementation
*/

var Thumbnails = $('#Thumbnails')[0],
    Stage = $('#Stage')[0],
    Trash = $('#Trash')[0],
    StartIndex, EndIndex;

dragula([ Thumbnails, Stage ], {
    copy: function(el, source) {
        return source === Thumbnails;
    },
    accepts: function(el, target) {
        return target === Stage;
    },
    removeOnSpill: function(el, target) {
        return target === Stage;
    }
}).on('drag', function(el, source) {

    if (source === Stage) {
        StartIndex = getIndex(Stage, el);
    }

}).on('drop', function(el, target, source, sibling) {
    /*
        Adding components to the staging area
    */
    if (source === Thumbnails) {
        var compName = $(el).attr('data-component');
        var stageSpot = 0;
        $(target).children().each(function(i) {
            if ($(this).hasClass('CompThumbWrap')) {
                stageSpot = i;
            }
        })
        $(el).remove();
        var compData = JSON.stringify(app.defaultComps[compName]);
        app.stageComps.insert(stageSpot, JSON.parse(compData));
    }
    /*
        Rearranging the order of components
    */
    if (source === Stage && target === Stage) {
        // EndIndex = getIndex(Stage, el);
        // setTimeout(function() {
        //     console.log(JSON.stringify(app.stageComps[StartIndex]))
        // }, 100)
        
        app.save();
        // var data = JSON.stringify(app.stageComps[StartIndex]);
        // app.stageComps.remove(StartIndex);
        // app.stageComps.insert(EndIndex, JSON.parse(data));
        // app.save();
    }
}).on('remove', function(el, container, source) {
    /*
        Removing components from the staging area
    */
    if (source === Stage) {
        app.stageComps.remove(StartIndex);
    }
})

function getIndex(area, item) {
    var index;
    $(area).children().each(function(i) {
        if (this === item) {
            index = i;
            return false;
        }
    })
    return index;
}


</script></body></html>