<!DOCTYPE html><html><head><title>Concepts</title>
<script src="https://unpkg.com/vue/dist/vue.js"></script>
<link rel="stylesheet" type="text/css" href="basic.css">
<link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.1/css/font-awesome.min.css">
<style type="text/css">
    body {
        padding-top: 5em;
    }
</style>
</head><body>

<div id="EditorToolbar"></div>

<div id="Stage2" class="VerticalSpacing">
    <comp-content v-for="comp in components" :comp_info="comp"></comp-content>
</div>

<div id="Thumbnails">
    <thumbnail v-for="comp in components" :comp_info="comp"></thumbnail>
</div>

<div class="overlay"></div>
<div class="decision">
    <div>Are you sure you want to delete this content?</div>
    <button class="yes">Yes, delete</button>
    <button class="no">Nope, stop</button>
</div>

<br><br>

<script src="//cdn.tinymce.com/4/tinymce.min.js"></script>
<script type="text/javascript" src="https://code.jquery.com/jquery-3.1.1.min.js"></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/dragula/3.7.2/dragula.min.js'></script>
<script type="text/javascript">

Array.prototype.insert = function(index, item) {
    this.splice(index, 0, item);
}
Array.prototype.remove = function(index) {
    this.splice(index, 1);
}
Array.prototype.reorder = function(from, to) {
    var _this = this;
    var isolated = _this.splice(from, 1)[0];
    Vue.nextTick(function() {
        _this.splice(to, 0, isolated);
    })
}

var ID = 0;
/*
    I need something that will insert saved html data into a container
    where the container is a tinymce editor instance. However, when the
    user updates the DOM via editing, I want the data to update but I 
    don't want the DOM to rerender since it has already changed and if it
    rerenders it will refocus the carrot. So, basically:
    Data -> DOM (one-way on init)
    DOM -> data (one-way on editing)
*/
Vue.directive('editor', {
    bind: function(el, binding, vnode) {
        Vue.nextTick(function() {
        // On intial binding, load what's in the data
        $(el).html(vnode.context.comp_config[binding.arg]);

        // check if element is a thumbnail
        if ($(vnode.context.$root.$el).attr('id') === 'Thumbnails') {
            return;
        }
        var id = genID(10);
        $(el).attr('data-editor-id', id);
        // Needs nextTick due to async rendering

            tinymce.init({
                selector: '[data-editor-id="'+id+'"]',
                plugins: 'link lists paste textpattern autolink',
                toolbar: 'undo redo bold italic alignleft aligncenter link bullist numlist',
                insert_toolbar: false,
                fixed_toolbar_container: '#EditorToolbar',
                menubar: false,
                inline: true,
                // attach a handler that will update the specific data
                // on keyup and any action that can be undone
                setup: function(ed) {
                    ed.on('Change keyup', function() {
                        vnode.context.comp_config[binding.arg] = ed.getContent();
                    })
                }
            })
        })
    }
})

// Toolbar is given to every staged component
Vue.component('comp-toolbar', {
    template: '\
        <div class="comp-toolbar">\
            <button class="btn-toolbar grab"><i class="fa fa-arrows"></i></button>\
            <button class="btn-toolbar"><i class="fa fa-clone"></i></button>\
            <button class="btn-toolbar" @click="remove"><i class="fa fa-trash-o"></i></button>\
            <button class="btn-toolbar"><i class="fa fa-cog"></i></button>\
        </div>',
    methods: {
        remove: function() {
            this.$emit('remove');
        }
    }
})

// Meta component - for stage
Vue.component('comp-content', {
    props: ['comp_info'],
    template: '\
        <div class="comp-content">\
            <component :is="comp_info.name" :comp_config="comp_info.config"></component>\
            <comp-toolbar v-on:remove="remove"></comp-toolbar>\
        </div>',
    methods: {
        remove: function() {
            var compId = this.props.id;
            var parent = this.$parent;
            this.$parent.components.forEach(function(comp, i) {
                if (comp.id === compId) {
                    decision('Are you sure you want to delete this content?',
                             'Yes, delete',
                             'No, stop',
                             function() {
                                parent.components.remove(i);
                             })
                }
            })
        }
    }
})

// Meta component - for thumbnails
Vue.component('thumbnail', {
    props: ['comp_info'],
    template: '\
        <div class="comp-thumbnail">\
            <span>{{ comp_info.display }}</span>\
            <component :is="comp_info.name" :comp_config="comp_info.config"></component>\
        </div>'
})


Vue.component('copy', {
    props: ['comp_config'],
    template: '<div v-editor:copy></div>'
})


var stage = new Vue({
    el: '#Stage2',
    data: {
        components: [
        ]
    }
})

var thumbnails = new Vue({
    el: '#Thumbnails',
    data: {
        components: [
            {
                name: 'copy',
                display: 'Copy',
                type: 'content',
                config: {
                    copy: '<p>Lorem ipsum copi textum</p>'
                }
            }
        ]
    }
})

var Stage = $('#Stage2')[0],
    Thumbnails = $('#Thumbnails')[0],
    StartIndex = 0,
    EndIndex = 0;

dragula([Stage, Thumbnails], {
    moves: function(el, container, grabber) {
        return container === Thumbnails || ($(grabber).hasClass('grab') || $(grabber).hasClass('fa-arrows'));
    },
    copy: function(el, source) {
        return source === Thumbnails;
    },
    accepts: function(el, target) {
        return target !== Thumbnails;
    }
}).on('drop', function(el, target, source, sibling) {

    

    // Add new component to stage
    if (source === Thumbnails && target === Stage) {
        EndIndex = getIndex(Stage, el);
        $(el).remove();
        var data = JSON.stringify(thumbnails.components[StartIndex]);
        stage.components.insert(EndIndex, JSON.parse(data));
    }

    // Rearrange components on stage
    if (source === Stage && target === Stage) {
        EndIndex = getIndex(Stage, el);
        var up = StartIndex > EndIndex;
        var long = StartIndex - EndIndex !== -1 && StartIndex - EndIndex !== 1;
        var comps = stage.components;
        // moving down by one
        if (!up && !long) {
            var moveData = copy(comps[StartIndex]),
                fixData = copy(comps[EndIndex]);
            Vue.set(comps, StartIndex, fixData);
            Vue.set(comps, EndIndex, moveData);
        }
    }

}).on('drag', function(el, source) {

    if (source === Thumbnails) {
        StartIndex = getIndex(Thumbnails, el);
    }

    if (source === Stage) {
        StartIndex = getIndex(Stage, el);
    }

})


$('.no, .yes').click(function() {
    $('.overlay, .decision').css({display: 'none'});
})


function decision(decMsg, yesMsg, noMsg, cb) {
    $('.overlay, .decision').css({display: 'block'});
    $('.decision div').html(decMsg);
    $('.yes').html('<i class="fa fa-check"></i> ' + yesMsg);
    $('.no').html('<i class="fa fa-close"></i> ' + noMsg);
    $('.yes').click(cb);
}

function random(min, max) {
    return Math.floor(Math.random() * (max - min + 1) + min);
}
  
function genID(num) {
    var id = 'ID-', i = 1;
    while (i <= num) {
        if (i % 2 === 0) {
            id += String.fromCharCode(random(65, 90));
        } else {
            id += String.fromCharCode(random(48, 57));
        }
        i++;
    }
    return id;
}

function copy(obj) {
    return JSON.parse(JSON.stringify(obj));
}

function getIndex(area, item) {
    var index;
    $(area).children().each(function(i) {
        if (this === item) {
            index = i;
            return false;
        }
    })
    return index;
}

</script></body></html>